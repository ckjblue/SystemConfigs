"use strict";
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const ms_rest_1 = require("ms-rest");
const opn = require("opn");
const request = require("request-promise");
const vscode = require("vscode");
const vscode_azureextensionui_1 = require("vscode-azureextensionui");
const extensionVariables_1 = require("./extensionVariables");
const localize_1 = require("./localize");
const signRequest_1 = require("./signRequest");
const nonNull_1 = require("./utils/nonNull");
function connectToGitHub(node, client) {
    return __awaiter(this, void 0, void 0, function* () {
        const requestOptions = new ms_rest_1.WebResource();
        let repoSelected = false;
        requestOptions.resolveWithFullResponse = true;
        requestOptions.headers = {
            ['User-Agent']: 'vscode-azureappservice-extension'
        };
        const oAuth2Token = (yield client.listSourceControls())[0].token;
        if (!oAuth2Token) {
            yield showGitHubAuthPrompt();
            // to prevent the GitHub appearing that it succeeded
            throw new vscode_azureextensionui_1.UserCancelledError();
        }
        yield signRequest_1.signRequest(requestOptions, new ms_rest_1.TokenCredentials(oAuth2Token));
        requestOptions.url = 'https://api.github.com/user';
        const gitHubUser = yield getJsonRequest(requestOptions, node);
        requestOptions.url = 'https://api.github.com/user/orgs';
        const gitHubOrgs = yield getJsonRequest(requestOptions, node);
        const orgQuickPicks = createQuickPickFromJsons([gitHubUser], 'login', undefined, ['repos_url']).concat(createQuickPickFromJsons(gitHubOrgs, 'login', undefined, ['repos_url']));
        const orgQuickPick = (yield extensionVariables_1.ext.ui.showQuickPick(orgQuickPicks, { placeHolder: 'Choose your organization.' })).data;
        let repoQuickPick;
        requestOptions.url = nonNull_1.nonNullProp(orgQuickPick, 'repos_url');
        const gitHubRepos = yield getJsonRequest(requestOptions, node);
        let repoQuickPicks = createQuickPickFromJsons(gitHubRepos, 'name', undefined, ['url', 'html_url']);
        do {
            if (requestOptions.nextLink && requestOptions.url !== requestOptions.lastLink) {
                // this makes sure that a nextLink exists and that the last requested url wasn't the last page
                repoQuickPicks.push({
                    label: '$(sync) Load More',
                    description: '',
                    data: {
                        url: requestOptions.nextLink
                    },
                    suppressPersistence: true
                });
            }
            repoQuickPick = (yield extensionVariables_1.ext.ui.showQuickPick(repoQuickPicks, { placeHolder: 'Choose project.' })).data;
            if (repoQuickPick.url === requestOptions.nextLink) {
                requestOptions.url = nonNull_1.nonNullProp(requestOptions, 'nextLink');
                // remove the stale Load More quick pick
                repoQuickPicks.pop();
                const moreGitHubRepos = yield getJsonRequest(requestOptions, node);
                repoQuickPicks = repoQuickPicks.concat(createQuickPickFromJsons(moreGitHubRepos, 'name', undefined, ['url', 'html_url']));
            }
            else {
                repoSelected = true;
            }
        } while (!repoSelected);
        requestOptions.url = `${repoQuickPick.url}/branches`;
        const gitHubBranches = yield getJsonRequest(requestOptions, node);
        const branchQuickPicks = createQuickPickFromJsons(gitHubBranches, 'name');
        const branchQuickPick = yield extensionVariables_1.ext.ui.showQuickPick(branchQuickPicks, { placeHolder: 'Choose branch.' });
        const siteSourceControl = {
            repoUrl: repoQuickPick.html_url,
            branch: branchQuickPick.label,
            isManualIntegration: false,
            deploymentRollbackEnabled: true,
            isMercurial: false
        };
        try {
            const connectingToGithub = localize_1.localize('ConnectingToGithub', '"{0}" is being connected to the GitHub repo. This may take several minutes...', client.fullName);
            const connectedToGithub = localize_1.localize('ConnectedToGithub', '"{0}" has been connected to the GitHub repo.', client.fullName);
            yield vscode.window.withProgress({ location: vscode.ProgressLocation.Notification, title: connectingToGithub }, () => __awaiter(this, void 0, void 0, function* () {
                extensionVariables_1.ext.outputChannel.appendLine(connectingToGithub);
                yield client.updateSourceControl(siteSourceControl);
                vscode.window.showInformationMessage(connectedToGithub);
                extensionVariables_1.ext.outputChannel.appendLine(connectedToGithub);
            }));
        }
        catch (err) {
            try {
                // a resync will fix the first broken build
                // https://github.com/projectkudu/kudu/issues/2277
                yield client.syncRepository();
            }
            catch (error) {
                const parsedError = vscode_azureextensionui_1.parseError(error);
                // The portal returns 200, but is expecting a 204 which causes it to throw an error even after a successful sync
                if (parsedError.message.indexOf('"statusCode":200') === -1) {
                    throw error;
                }
            }
        }
    });
}
exports.connectToGitHub = connectToGitHub;
function showGitHubAuthPrompt() {
    return __awaiter(this, void 0, void 0, function* () {
        const learnMore = localize_1.localize('learnMore', 'Learn More');
        const setupGithub = localize_1.localize('setupGithub', 'You must give Azure access to your GitHub account.');
        const input = yield vscode.window.showErrorMessage(setupGithub, learnMore);
        if (input === learnMore) {
            // tslint:disable-next-line:no-unsafe-any
            opn('https://aka.ms/B7g6sw');
        }
    });
}
function getJsonRequest(requestOptions, node) {
    return __awaiter(this, void 0, void 0, function* () {
        // Reference for GitHub REST routes
        // https://developer.github.com/v3/
        // Note: blank after user implies look up authorized user
        try {
            // tslint:disable-next-line:no-unsafe-any
            const gitHubResponse = yield request(requestOptions).promise();
            if (gitHubResponse.headers.link) {
                const headerLink = gitHubResponse.headers.link;
                const linkObject = parseLinkHeaderToGitHubLinkObject(headerLink);
                if (linkObject.next) {
                    requestOptions.nextLink = linkObject.next;
                }
                if (linkObject.last) {
                    requestOptions.lastLink = linkObject.last;
                }
            }
            // tslint:disable-next-line:no-unsafe-any
            return JSON.parse(gitHubResponse.body);
        }
        catch (error) {
            const parsedError = vscode_azureextensionui_1.parseError(error);
            if (parsedError.message.indexOf('Bad credentials') > -1) {
                // the default error is just "Bad Credentials," which is an unhelpful error message
                const tokenExpired = localize_1.localize('tokenExpired', 'Azure\'s GitHub token has expired.  Reauthorize in the Portal under "Deployment options."');
                const goToPortal = localize_1.localize('goToPortal', 'Go to Portal');
                const input = yield vscode.window.showErrorMessage(tokenExpired, goToPortal);
                if (input === goToPortal) {
                    node.openInPortal();
                    // https://github.com/Microsoft/vscode-azuretools/issues/78
                    throw new vscode_azureextensionui_1.UserCancelledError();
                }
                else {
                    throw new vscode_azureextensionui_1.UserCancelledError();
                }
            }
            else {
                throw error;
            }
        }
    });
}
/**
 * @param label Property of JSON that will be used as the QuickPicks label
 * @param description Optional property of JSON that will be used as QuickPicks description
 * @param data Optional property of JSON that will be used as QuickPicks data saved as a NameValue pair
 */
function createQuickPickFromJsons(jsons, label, description, data) {
    const quickPicks = [];
    for (const json of jsons) {
        const dataValuePair = {};
        if (!json[label]) {
            // skip this JSON if it doesn't have this label
            continue;
        }
        if (description && !json[description]) {
            // if the label exists, but the description does not, then description will just be left blank
            description = undefined;
        }
        if (data) {
            // construct value pair based off data labels provided
            for (const property of data) {
                // required to construct first otherwise cannot use property as key name
                dataValuePair[property] = json[property];
            }
        }
        quickPicks.push({
            label: json[label],
            description: `${description ? json[description] : ''}`,
            data: dataValuePair
        });
    }
    return quickPicks;
}
function parseLinkHeaderToGitHubLinkObject(linkHeader) {
    const linkUrls = linkHeader.split(', ');
    const linkMap = {};
    // link header response is "<https://api.github.com/organizations/6154722/repos?page=2>; rel="prev", <https://api.github.com/organizations/6154722/repos?page=4>; rel="next""
    const relative = 'rel=';
    for (const url of linkUrls) {
        linkMap[url.substring(url.indexOf(relative) + relative.length + 1, url.length - 1)] = url.substring(url.indexOf('<') + 1, url.indexOf('>'));
    }
    return linkMap;
}
//# sourceMappingURL=connectToGitHub.js.map