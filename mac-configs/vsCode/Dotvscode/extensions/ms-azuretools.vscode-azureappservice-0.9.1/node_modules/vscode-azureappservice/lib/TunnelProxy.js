"use strict";
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const EventEmitter = require("events");
const net_1 = require("net");
const request = require("request");
const util_1 = require("util");
const websocket = require("websocket");
const extensionVariables_1 = require("./extensionVariables");
/**
 * Wrapper for net.Socket that forwards all traffic to the Kudu tunnel websocket endpoint.
 * Used internally by the TunnelProxy server.
 */
class TunnelSocket extends EventEmitter {
    constructor(socket, client, publishCredential) {
        super();
        this._socket = socket;
        this._client = client;
        this._publishCredential = publishCredential;
        this._wsClient = new websocket.client();
    }
    connect() {
        extensionVariables_1.ext.outputChannel.appendLine('[Proxy Server] socket init');
        // Pause socket until tunnel connection has been established to make sure we don't lose data
        this._socket.pause();
        this._socket.on('data', (data) => {
            if (this._wsConnection) {
                this._wsConnection.send(data);
            }
        });
        this._socket.on('close', () => {
            extensionVariables_1.ext.outputChannel.appendLine(`[Proxy Server] client disconnected ${this._socket.remoteAddress}:${this._socket.remotePort}`);
            this.dispose();
            this.emit('close');
        });
        this._socket.on('error', (err) => {
            extensionVariables_1.ext.outputChannel.appendLine(`[Proxy Server] socket error: ${err}`);
            this.dispose();
            this.emit('error', err);
        });
        this._wsClient.on('connect', (connection) => {
            extensionVariables_1.ext.outputChannel.appendLine('[WebSocket] client connected');
            this._wsConnection = connection;
            // Resume socket after connection
            this._socket.resume();
            connection.on('close', () => {
                extensionVariables_1.ext.outputChannel.appendLine('[WebSocket] client closed');
                this.dispose();
                this.emit('close');
            });
            connection.on('error', (err) => {
                extensionVariables_1.ext.outputChannel.appendLine(`[WebSocket] error: ${err}`);
                this.dispose();
                this.emit('error', err);
            });
            connection.on('message', (data) => {
                this._socket.write(data.binaryData);
            });
        });
        this._wsClient.on('connectFailed', (err) => {
            extensionVariables_1.ext.outputChannel.appendLine(`[WebSocket] connectFailed: ${err}`);
            this.dispose();
            this.emit('error', err);
        });
        this._wsClient.connect(`wss://${this._client.kuduHostName}/AppServiceTunnel/Tunnel.ashx`, undefined, undefined, {
            'User-Agent': 'vscode-azuretools',
            'Cache-Control': 'no-cache',
            Pragma: 'no-cache'
        }, {
            auth: `${this._publishCredential.publishingUserName}:${this._publishCredential.publishingPassword}`
        });
    }
    dispose() {
        extensionVariables_1.ext.outputChannel.appendLine('[Proxy Server] socket dispose');
        if (this._wsConnection) {
            this._wsConnection.close();
            this._wsConnection = undefined;
        }
        if (this._wsClient) {
            this._wsClient.abort();
            this._wsClient = undefined;
        }
        if (this._socket) {
            this._socket.destroy();
            this._socket = undefined;
        }
    }
}
/**
 * A local TCP server that forwards all connections to the Kudu tunnel websocket endpoint.
 */
class TunnelProxy {
    constructor(port, client, publishCredential) {
        this._port = port;
        this._client = client;
        this._publishCredential = publishCredential;
        this._server = net_1.createServer();
        this._openSockets = [];
    }
    startProxy() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.checkTunnelStatusWithRetry();
            yield this.setupTunnelServer();
        });
    }
    dispose() {
        this._openSockets.forEach((tunnelSocket) => {
            tunnelSocket.dispose();
        });
        this._server.close();
        this._server.unref();
    }
    checkTunnelStatus() {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => {
                const statusOptions = {
                    uri: `https://${this._client.kuduHostName}/AppServiceTunnel/Tunnel.ashx?GetStatus`,
                    headers: {
                        'User-Agent': 'vscode-azuretools'
                    },
                    auth: {
                        user: this._publishCredential.publishingUserName,
                        pass: this._publishCredential.publishingPassword
                    }
                };
                const statusCallback = (error, response, body) => {
                    if (error) {
                        extensionVariables_1.ext.outputChannel.appendLine(`[WebApp Tunnel] Checking status, error: ${error}`);
                        reject();
                    }
                    else if (response.statusCode === 200) {
                        extensionVariables_1.ext.outputChannel.appendLine(`[WebApp Tunnel] Checking status, body: ${body}`);
                        // SUCCESS:2222 means that the default ssh tunnel has not been replaced yet
                        if (util_1.isString(body) && body.startsWith('SUCCESS') && body !== 'SUCCESS:2222') {
                            resolve();
                        }
                        else {
                            reject();
                        }
                    }
                    else {
                        extensionVariables_1.ext.outputChannel.appendLine(`[WebApp Tunnel] Checking status, unexpected response: ${response.statusCode} - ${response.statusMessage}`);
                        reject();
                    }
                };
                request.get(statusOptions, statusCallback);
            });
        });
    }
    checkTunnelStatusWithRetry() {
        return __awaiter(this, void 0, void 0, function* () {
            const timeoutSeconds = 240; // 4 minutes, matches App Service internal timeout for starting up an app
            const timeoutMs = timeoutSeconds * 1000;
            const pollingIntervalMs = 5000;
            const delay = (delayMs) => __awaiter(this, void 0, void 0, function* () {
                yield new Promise((resolve) => { setTimeout(resolve, delayMs); });
            });
            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
                const start = Date.now();
                while (Date.now() < start + timeoutMs) {
                    try {
                        yield this.checkTunnelStatus();
                        resolve();
                        return;
                    }
                    catch (_a) {
                        // Suppress error and try again
                    }
                    yield delay(pollingIntervalMs);
                }
                reject(new Error(`Unable to establish connection to application after ${timeoutSeconds} seconds`));
            }));
        });
    }
    setupTunnelServer() {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => {
                this._server.on('connection', (socket) => {
                    const tunnelSocket = new TunnelSocket(socket, this._client, this._publishCredential);
                    this._openSockets.push(tunnelSocket);
                    tunnelSocket.on('close', () => {
                        const index = this._openSockets.indexOf(tunnelSocket);
                        if (index >= 0) {
                            this._openSockets.splice(index, 1);
                            extensionVariables_1.ext.outputChannel.appendLine(`[Proxy Server] client closed, connection count: ${this._openSockets.length}`);
                        }
                    });
                    tunnelSocket.connect();
                    extensionVariables_1.ext.outputChannel.appendLine(`[Proxy Server] client connected ${socket.remoteAddress}:${socket.remotePort}, connection count: ${this._openSockets.length}`);
                });
                this._server.on('listening', () => {
                    extensionVariables_1.ext.outputChannel.appendLine('[Proxy Server] start listening');
                    resolve();
                });
                this._server.on('error', (err) => {
                    extensionVariables_1.ext.outputChannel.appendLine(`[Proxy Server] server error: ${err}`);
                    this.dispose();
                    reject(err);
                });
                this._server.listen({
                    host: 'localhost',
                    port: this._port,
                    backlog: 1
                });
            });
        });
    }
}
exports.TunnelProxy = TunnelProxy;
//# sourceMappingURL=TunnelProxy.js.map